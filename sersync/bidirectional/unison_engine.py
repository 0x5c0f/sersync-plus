"""
Unison 同步引擎

功能:
- 集成 Unison 双向文件同步工具
- 支持 SSH 远程同步
- 自动冲突处理
- 增量传输
"""

from pathlib import Path
from typing import Optional, List, Dict, Any
import asyncio
import structlog
import shutil

from sersync.bidirectional.conflict_resolver import ResolutionStrategy

logger = structlog.get_logger()


class UnisonProfile:
    """Unison 配置文件"""

    def __init__(
        self,
        name: str,
        local_root: str,
        remote_root: str,
        remote_host: Optional[str] = None,
        remote_user: Optional[str] = None,
        ssh_port: int = 22,
        ignore_patterns: Optional[List[str]] = None,
        prefer: str = "newer",  # newer, older, local, remote
        auto: bool = False,
        batch: bool = True,
        times: bool = True,
        perms: int = 0o644,
        fastcheck: bool = True,
        fat: bool = False,
        copyonconflict: bool = True
    ):
        """
        初始化 Unison 配置

        Args:
            name: 配置文件名
            local_root: 本地根目录
            remote_root: 远程根目录路径
            remote_host: 远程主机（SSH 模式）
            remote_user: 远程用户（SSH 模式）
            ssh_port: SSH 端口
            ignore_patterns: 忽略模式列表
            prefer: 冲突解决偏好 (newer, older, local, remote)
            auto: 自动接受默认操作
            batch: 批处理模式（无交互）
            times: 同步修改时间
            perms: 文件权限（八进制）
            fastcheck: 快速检查（基于时间戳）
            fat: FAT 文件系统兼容模式
            copyonconflict: 冲突时复制文件
        """
        self.name = name
        self.local_root = local_root
        self.remote_root = remote_root
        self.remote_host = remote_host
        self.remote_user = remote_user
        self.ssh_port = ssh_port
        self.ignore_patterns = ignore_patterns or []
        self.prefer = prefer
        self.auto = auto
        self.batch = batch
        self.times = times
        self.perms = perms
        self.fastcheck = fastcheck
        self.fat = fat
        self.copyonconflict = copyonconflict

    def generate_profile_content(self) -> str:
        """
        生成 Unison 配置文件内容

        Returns:
            配置文件内容
        """
        lines = []

        # 根目录
        lines.append(f"# Unison Profile: {self.name}")
        lines.append(f"# Generated by Sersync")
        lines.append("")

        lines.append(f"root = {self.local_root}")

        # 远程根目录
        if self.remote_host:
            # SSH 模式
            user_part = f"{self.remote_user}@" if self.remote_user else ""
            lines.append(f"root = ssh://{user_part}{self.remote_host}/{self.remote_root}")

            # SSH 参数
            ssh_args = ["-p", str(self.ssh_port)]
            lines.append(f"sshargs = {' '.join(ssh_args)}")
        else:
            # 本地模式
            lines.append(f"root = {self.remote_root}")

        lines.append("")

        # 忽略模式
        if self.ignore_patterns:
            lines.append("# Ignore patterns")
            for pattern in self.ignore_patterns:
                lines.append(f"ignore = {pattern}")
            lines.append("")

        # 同步选项
        lines.append("# Sync options")
        lines.append(f"prefer = {self.prefer}")
        lines.append(f"auto = {'true' if self.auto else 'false'}")
        lines.append(f"batch = {'true' if self.batch else 'false'}")
        lines.append(f"times = {'true' if self.times else 'false'}")
        lines.append(f"perms = {oct(self.perms)}")
        lines.append(f"fastcheck = {'true' if self.fastcheck else 'false'}")
        lines.append(f"fat = {'true' if self.fat else 'false'}")
        lines.append(f"copyonconflict = {'true' if self.copyonconflict else 'false'}")
        lines.append("")

        # 其他选项
        lines.append("# Other options")
        lines.append("silent = false")
        lines.append("log = true")
        lines.append("logfile = /var/log/sersync/unison.log")
        lines.append("")

        return "\n".join(lines)

    def save(self, profile_dir: str = None) -> str:
        """
        保存配置文件

        Args:
            profile_dir: 配置文件目录（默认 ~/.unison）

        Returns:
            配置文件路径
        """
        if profile_dir is None:
            profile_dir = Path.home() / ".unison"
        else:
            profile_dir = Path(profile_dir)

        # 创建目录
        profile_dir.mkdir(parents=True, exist_ok=True)

        # 写入配置文件
        profile_path = profile_dir / f"{self.name}.prf"
        profile_path.write_text(self.generate_profile_content())

        logger.info("Unison profile saved", path=str(profile_path))
        return str(profile_path)


class UnisonSyncResult:
    """Unison 同步结果"""

    def __init__(
        self,
        success: bool,
        exit_code: int,
        stdout: str,
        stderr: str,
        files_updated: int = 0,
        files_deleted: int = 0,
        conflicts: int = 0,
        duration_seconds: float = 0.0
    ):
        """
        初始化同步结果

        Args:
            success: 是否成功
            exit_code: 退出代码
            stdout: 标准输出
            stderr: 标准错误
            files_updated: 更新的文件数
            files_deleted: 删除的文件数
            conflicts: 冲突数
            duration_seconds: 同步耗时（秒）
        """
        self.success = success
        self.exit_code = exit_code
        self.stdout = stdout
        self.stderr = stderr
        self.files_updated = files_updated
        self.files_deleted = files_deleted
        self.conflicts = conflicts
        self.duration_seconds = duration_seconds

    def to_dict(self) -> Dict[str, Any]:
        """转换为字典"""
        return {
            'success': self.success,
            'exit_code': self.exit_code,
            'files_updated': self.files_updated,
            'files_deleted': self.files_deleted,
            'conflicts': self.conflicts,
            'duration_seconds': self.duration_seconds
        }

    def __repr__(self):
        return (
            f"UnisonSyncResult(success={self.success}, "
            f"updated={self.files_updated}, "
            f"deleted={self.files_deleted}, "
            f"conflicts={self.conflicts})"
        )


class UnisonEngine:
    """Unison 同步引擎"""

    def __init__(
        self,
        profile: UnisonProfile,
        unison_path: str = "/usr/bin/unison",
        timeout_seconds: int = 3600,
        retry_count: int = 3
    ):
        """
        初始化 Unison 引擎

        Args:
            profile: Unison 配置
            unison_path: Unison 可执行文件路径
            timeout_seconds: 超时时间（秒）
            retry_count: 重试次数
        """
        self.profile = profile
        self.unison_path = unison_path
        self.timeout_seconds = timeout_seconds
        self.retry_count = retry_count

        # 检查 Unison 是否已安装
        if not shutil.which(unison_path) and not Path(unison_path).exists():
            logger.warning(
                "Unison not found",
                path=unison_path,
                hint="Install with: apt install unison or brew install unison"
            )
            self.unison_available = False
        else:
            self.unison_available = True
            logger.info("Unison engine initialized", unison_path=unison_path)

    def is_available(self) -> bool:
        """检查 Unison 是否可用"""
        return self.unison_available

    async def sync(
        self,
        path_filter: Optional[str] = None,
        force_direction: Optional[str] = None
    ) -> UnisonSyncResult:
        """
        执行同步

        Args:
            path_filter: 路径过滤器（只同步匹配的路径）
            force_direction: 强制同步方向 ("local-to-remote" 或 "remote-to-local")

        Returns:
            UnisonSyncResult
        """
        if not self.unison_available:
            return UnisonSyncResult(
                success=False,
                exit_code=-1,
                stdout="",
                stderr="Unison not available"
            )

        # 保存配置文件
        profile_path = self.profile.save()

        # 构建命令
        cmd = [self.unison_path, self.profile.name]

        # 添加选项
        if path_filter:
            cmd.extend(["-path", path_filter])

        if force_direction:
            if force_direction == "local-to-remote":
                cmd.extend(["-force", self.profile.local_root])
            elif force_direction == "remote-to-local":
                remote_root = f"ssh://{self.profile.remote_host}/{self.profile.remote_root}"
                cmd.extend(["-force", remote_root])

        # 批处理模式
        cmd.append("-batch")

        logger.info(
            "Starting Unison sync",
            profile=self.profile.name,
            path_filter=path_filter,
            force_direction=force_direction
        )

        # 执行同步（带重试）
        for attempt in range(self.retry_count):
            try:
                import time
                start_time = time.time()

                result = await self._run_unison(cmd)

                duration = time.time() - start_time

                # 解析输出
                parsed_result = self._parse_output(
                    result['stdout'],
                    result['stderr'],
                    result['exit_code'],
                    duration
                )

                if parsed_result.success:
                    logger.info(
                        "Unison sync completed",
                        files_updated=parsed_result.files_updated,
                        files_deleted=parsed_result.files_deleted,
                        conflicts=parsed_result.conflicts,
                        duration=f"{duration:.2f}s"
                    )
                    return parsed_result
                else:
                    logger.warning(
                        "Unison sync failed",
                        attempt=attempt + 1,
                        exit_code=result['exit_code']
                    )

                    if attempt < self.retry_count - 1:
                        # 等待后重试
                        await asyncio.sleep(2 ** attempt)  # 指数退避
                    else:
                        return parsed_result

            except asyncio.TimeoutError:
                logger.error(
                    "Unison sync timeout",
                    timeout=self.timeout_seconds,
                    attempt=attempt + 1
                )

                if attempt >= self.retry_count - 1:
                    return UnisonSyncResult(
                        success=False,
                        exit_code=-1,
                        stdout="",
                        stderr=f"Timeout after {self.timeout_seconds} seconds"
                    )

            except Exception as e:
                logger.error(
                    "Unison sync error",
                    error=str(e),
                    attempt=attempt + 1,
                    exc_info=True
                )

                if attempt >= self.retry_count - 1:
                    return UnisonSyncResult(
                        success=False,
                        exit_code=-1,
                        stdout="",
                        stderr=str(e)
                    )

        # 不应该到达这里
        return UnisonSyncResult(
            success=False,
            exit_code=-1,
            stdout="",
            stderr="Unknown error"
        )

    async def _run_unison(self, cmd: List[str]) -> Dict[str, Any]:
        """
        运行 Unison 命令

        Args:
            cmd: 命令列表

        Returns:
            结果字典 {'exit_code', 'stdout', 'stderr'}
        """
        # 尝试创建子进程，处理 Python 3.12 的兼容性问题
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            try:
                stdout, stderr = await asyncio.wait_for(
                    process.communicate(),
                    timeout=self.timeout_seconds
                )

                return {
                    'exit_code': process.returncode,
                    'stdout': stdout.decode('utf-8', errors='ignore'),
                    'stderr': stderr.decode('utf-8', errors='ignore')
                }

            except asyncio.TimeoutError:
                # 超时，终止进程
                process.kill()
                await process.wait()
                return {
                    'exit_code': -1,
                    'stdout': '',
                    'stderr': 'Command timed out'
                }
                
        except NotImplementedError:
            # Python 3.12 在某些情况下可能抛出 NotImplementedError
            # 回退到使用 subprocess.Popen 的同步方式
            logger.debug("Falling back to synchronous subprocess execution for unison")
            import subprocess
            
            try:
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE
                )
                stdout, stderr = process.communicate(timeout=self.timeout_seconds)
                
                return {
                    'exit_code': process.returncode,
                    'stdout': stdout.decode('utf-8', errors='ignore'),
                    'stderr': stderr.decode('utf-8', errors='ignore')
                }
                
            except subprocess.TimeoutExpired:
                process.kill()
                process.wait()
                return {
                    'exit_code': -1,
                    'stdout': '',
                    'stderr': 'Command timed out'
                }
            raise

    def _parse_output(
        self,
        stdout: str,
        stderr: str,
        exit_code: int,
        duration: float
    ) -> UnisonSyncResult:
        """
        解析 Unison 输出

        Args:
            stdout: 标准输出
            stderr: 标准错误
            exit_code: 退出代码
            duration: 执行时长

        Returns:
            UnisonSyncResult
        """
        # Unison 退出代码：
        # 0 = 成功
        # 1 = 部分失败（有冲突）
        # 2+ = 错误

        success = exit_code == 0

        # 解析统计信息
        files_updated = 0
        files_deleted = 0
        conflicts = 0

        # 从输出中提取统计信息
        for line in stdout.split('\n'):
            line_lower = line.lower()

            if 'updated' in line_lower or 'changed' in line_lower:
                # 尝试提取数字
                import re
                match = re.search(r'(\d+)\s+(?:file|item)', line)
                if match:
                    files_updated += int(match.group(1))

            if 'deleted' in line_lower:
                match = re.search(r'(\d+)\s+(?:file|item)', line)
                if match:
                    files_deleted += int(match.group(1))

            if 'conflict' in line_lower:
                match = re.search(r'(\d+)\s+conflict', line)
                if match:
                    conflicts += int(match.group(1))

        # 如果有冲突，标记为部分成功
        if conflicts > 0 and exit_code == 1:
            success = False

        return UnisonSyncResult(
            success=success,
            exit_code=exit_code,
            stdout=stdout,
            stderr=stderr,
            files_updated=files_updated,
            files_deleted=files_deleted,
            conflicts=conflicts,
            duration_seconds=duration
        )

    async def test_connection(self) -> bool:
        """
        测试连接

        Returns:
            True 如果连接成功
        """
        if not self.unison_available:
            return False

        try:
            # 运行 Unison 测试命令
            cmd = [self.unison_path, "-version"]
            result = await self._run_unison(cmd)

            if result['exit_code'] == 0:
                logger.info("Unison connection test passed")
                return True
            else:
                logger.error("Unison connection test failed")
                return False

        except Exception as e:
            logger.error("Unison connection test error", error=str(e))
            return False

    def set_resolution_strategy(self, strategy: ResolutionStrategy):
        """
        设置冲突解决策略

        Args:
            strategy: 解决策略
        """
        # 映射到 Unison 的 prefer 选项
        strategy_map = {
            ResolutionStrategy.KEEP_NEWER: "newer",
            ResolutionStrategy.KEEP_OLDER: "older",
            ResolutionStrategy.KEEP_LOCAL: "local",
            ResolutionStrategy.KEEP_REMOTE: "remote",
        }

        prefer = strategy_map.get(strategy)
        if prefer:
            self.profile.prefer = prefer
            logger.info("Unison prefer strategy updated", prefer=prefer)
        else:
            logger.warning(
                "Strategy not supported by Unison",
                strategy=strategy.value
            )
